#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <apr.h>
#include <apr_time.h>
#include <apr_pools.h>
#include <apr_poll.h>
#include <apr_network_io.h>
#include <apr_signal.h>       
#include <apr_thread_proc.h>  /* for apr_proc_detach(). no threads. */
#include <apr_tables.h>

#include "cmdline.h"   /* generated by cmdline.sh which runs gengetopt */
#include "confuse.h"   /* header for libconfuse in ./srclib/confuse */
#include "conf.h"      /* configuration file definition in libconfuse format */
#include "become_a_nobody.h"
#include "libmetrics.h"/* libmetrics header in ./srclib/libmetrics */
#include "apr_net.h"   /* our private network functions based on apr */
#include "debug_msg.h" 
#include "protocol.h"

/* When this gmond was started */
apr_time_t started;
/* My name */
char myname[APRMAXHOSTLEN+1];
/* The commandline options */
struct gengetopt_args_info args_info;
/* The configuration file */
cfg_t *config_file;
/* The debug level (in debug_msg.c) */
extern int debug_level;
/* The global context */
apr_pool_t *global_context = NULL;
/* Deaf mode boolean */
int deaf;
/* Mute mode boolean */
int mute;
/* Maximum UDP message size.. TODO: allow tweakability */
int max_udp_message_len = 1500;
/* The pollset for incoming UDP messages */
apr_pollset_t *udp_recv_pollset = NULL;
/* The array for outgoing UDP message */
apr_array_header_t *udp_send_array = NULL;

static void
process_configuration_file(void)
{
  config_file = cfg_init( gmond_opts, CFGF_NOCASE );
  switch( cfg_parse( config_file, args_info.conf_arg ) )
    {
    case CFG_FILE_ERROR:
      /* Unable to open file so we'll go with the configuration defaults */
      fprintf(stderr,"Configuration file '%s' not found.\n", args_info.conf_arg);
      if(args_info.conf_given)
	{
	  /* If they explicitly stated a configuration file exit with error... */
	  exit(1);
	}
      /* .. otherwise use our default configuration */
      fprintf(stderr,"Using defaults.\n");
      cfg_parse_buf(config_file, DEFAULT_CONFIGURATION);
      break;
    case CFG_PARSE_ERROR:
      fprintf(stderr,"Parse error for '%s'\n", args_info.conf_arg);
      exit(1);
    case CFG_SUCCESS:
      break;
    default:
      /* I have no cluse whats goin' on here... */
      exit(1);
    }
}

static void
initialize_apr_library( void )
{
  apr_status_t status;

  /* Initialize apr */
  status = apr_initialize();
  if(status != APR_SUCCESS)
    {
      fprintf(stderr,"Unable to initialize APR library. Exiting.\n");
      exit(1);
    }

  /* Create the global context */
  status = apr_pool_create( &global_context, NULL );
  if(status != APR_SUCCESS)
    {
      fprintf(stderr,"Unable to create global context. Exiting.\n");
      exit(1);
    }

  /* Setup atexit() calls to cleanup? */
}

static void
daemonize_if_necessary( char *argv[] )
{
  int should_daemonize;
  cfg_t *tmp;
  tmp = cfg_getsec( config_file, "behavior");
  should_daemonize = cfg_getbool( tmp, "daemonize");

  /* Commandline for debug_level trumps configuration file behaviour ... */
  if (args_info.debug_given) 
    {
      debug_level = args_info.debug_arg;
    }
  else
    {
      debug_level = cfg_getint ( tmp, "debug_level");
    }

  /* Daemonize if needed */
  if(!args_info.foreground_flag && should_daemonize && !debug_level)
    {
      apr_proc_detach(1);
    }
}

static void
setuid_if_necessary( void )
{
  cfg_t *tmp;
  int setuid;
  char *user;

  tmp    = cfg_getsec( config_file, "behavior");
  setuid = cfg_getbool( tmp, "setuid" );
  if(setuid)
    {
      user = cfg_getstr(tmp, "user" );
      become_a_nobody(user);
    }
}

static void
process_deaf_mute_mode( void )
{
  cfg_t *tmp = cfg_getsec( config_file, "behavior");
  deaf =       cfg_getbool( tmp, "deaf");
  mute =       cfg_getbool( tmp, "mute");
  if(deaf && mute)
    {
      fprintf(stderr,"Configured to run both deaf and mute. Nothing to do. Exiting.\n");
      exit(1);
    }
}

static void
setup_udp_recv_pollset( void )
{
  apr_status_t status;
  /* We will open sockets to listen for messages */
  int i, num_udp_recv_channels = cfg_size( config_file, "udp_recv_channel");

  /* Create my UDP recv pollset */
  apr_pollset_create(&udp_recv_pollset, num_udp_recv_channels, global_context, 0);

  for(i = 0; i< num_udp_recv_channels; i++)
    {
      cfg_t *udp_recv_channel;
      char *mcast_join, *mcast_if, *bindaddr, *protocol;
      int port;
      apr_socket_t *socket = NULL;
      apr_pollfd_t socket_pollfd;

      udp_recv_channel = cfg_getnsec( config_file, "udp_recv_channel", i);
      mcast_join     = cfg_getstr( udp_recv_channel, "mcast_join" );
      mcast_if       = cfg_getstr( udp_recv_channel, "mcast_if" );
      port           = cfg_getint( udp_recv_channel, "port");
      bindaddr       = cfg_getstr( udp_recv_channel, "bind");
      protocol       = cfg_getstr( udp_recv_channel, "protocol");

      debug_msg("udp_recv_channel mcast_join=%s mcast_if=%s port=%d bind=%s protocol=%s\n",
		  mcast_join? mcast_join:"NULL", 
		  mcast_if? mcast_if:"NULL",
		  port, 
		  bindaddr? bindaddr: "NULL",
		  protocol? protocol:"NULL");

      /* Create a standard UDP socket */
      socket = create_udp_server( global_context, port, bindaddr );
      if(!socket)
        {
          fprintf(stderr,"Error creating UDP server on port %d bind=%s. Exiting.\n",
		      port, bindaddr? bindaddr: "unspecified");
	  exit(1);
	}

      if( mcast_join )
	{
	  /* Join the specified multicast channel */
	  socket = NULL;  /* later */
	  /*create_mcast_server( global_context, mcast_join, port, mcast_if );*/
	  if(!socket)
	    {
	      fprintf(stderr,"Error creating multicast server mcast_join=%s port=%d mcast_if=%s. Exiting.\n",
		      mcast_join? mcast_join: "NULL", port, mcast_if? mcast_if:"NULL");
	      exit(1);
	    }

	}

      /* Build the socket poll file descriptor structure */
      socket_pollfd.desc_type   = APR_POLL_SOCKET;
      socket_pollfd.reqevents   = APR_POLLIN;
      socket_pollfd.desc.s      = socket;
      socket_pollfd.client_data = protocol;

      /* Add the socket to the pollset */
      status = apr_pollset_add(udp_recv_pollset, &socket_pollfd);
      if(status != APR_SUCCESS)
	{
	  fprintf(stderr,"Failed to add socket to pollset. Exiting.\n");
	  exit(1);
	}
    }
}

static void
poll_udp_recv_channels(apr_interval_time_t timeout)
{
  apr_status_t status;
  const apr_pollfd_t *descs = NULL;
  apr_int32_t i, num = 0;
  apr_socket_t *socket = NULL;

  /* Poll for data with given timeout */
  status = apr_pollset_poll(udp_recv_pollset, timeout, &num, &descs);
  if(status != APR_SUCCESS)
    return;

  if(num>0)
    {
      /* We have data to read */
      for(i=0; i< num; i++)
        {
	  char buf[max_udp_message_len]; 
	  apr_sockaddr_t from;
	  apr_size_t len = 1500;
	  char *protocol;

	  socket   = descs[i].desc.s;
	  protocol = descs[i].client_data; 

	  status = apr_socket_recvfrom(&from, socket, 0, buf, &len);
	  if(status != APR_SUCCESS)
	    {
	      continue;
	    }	  

	  /* TODO: Check the "from" apr_sockaddr_t to see if we trust 'em */

	  if(!strcasecmp(protocol, "xdr"))
	    {
	      XDR x;
	      gangliaMessage message;

              /* Create the XDR receive stream */
	      xdrmem_create(&x, buf, max_udp_message_len, XDR_DECODE);

              /* Flush the data in the (last) received gangliaMessage 
	       * TODO: Free memory from xdr_string calls XDR_FREE */
	      memset( &message, 0, sizeof(gangliaMessage));

	      /* Read the gangliaMessage from the stream */
	      if(!xdr_gangliaMessage(&x, &message))
                {	
	          continue;
	        }

	      /* If I want to find out how much data I decoded 
	      decoded = xdr_getpos(&x); */
	      if(message.format < MAX_NUM_GANGLIA_FORMATS)
		{
	          fprintf(stderr,"Got a complete ganglia message (format=%d) (len=%d)\n", message.format,len);
		}
	      else
		{
		  fprintf(stderr,"Format (%d) is out of range (len=%d).\n", message.format,len);
		}
	    }
        } 
    }
}

static void
setup_udp_send_array( void )
{
  int i, num_udp_send_channels = cfg_size( config_file, "udp_send_channel");

  if(num_udp_send_channels <= 0)
    return;

  /* Create my UDP send array */
  udp_send_array = apr_array_make( global_context, num_udp_send_channels, 
				   sizeof(apr_socket_t *));

  for(i = 0; i< num_udp_send_channels; i++)
    {
      cfg_t *udp_send_channel;
      char *mcast_join, *mcast_if, *protocol, *ip;
      int port;
      apr_socket_t *socket = NULL;

      udp_send_channel = cfg_getnsec( config_file, "udp_send_channel", i);
      ip             = cfg_getstr( udp_send_channel, "ip" );
      mcast_join     = cfg_getstr( udp_send_channel, "mcast_join" );
      mcast_if       = cfg_getstr( udp_send_channel, "mcast_if" );
      port           = cfg_getint( udp_send_channel, "port");
      protocol       = cfg_getstr( udp_send_channel, "protocol");

      debug_msg("udp_send_channel mcast_join=%s mcast_if=%s ip=%s port=%d protocol=%s\n",
		  mcast_join? mcast_join:"NULL", 
		  mcast_if? mcast_if:"NULL",
		  ip,
		  port, 
		  protocol? protocol:"NULL");

      /* Create a standard UDP socket */
      socket = create_udp_client( global_context, ip, port );
      if(!socket)
        {
          fprintf(stderr,"Unable to create UDP client for %s:%d. Exiting.\n",
		      ip? ip: "NULL", port);
	  exit(1);
	}

      /* Join the specified multicast channel */
      if( mcast_join )
	{
	  /* We'll be listening on a multicast channel */
	  socket = NULL;
	  if(!socket)
	    {
	      fprintf(stderr,"Unable to join multicast channel %s:%d. Exiting\n",
		      mcast_join, port);
	      exit(1);
	    }
	}

      /* Add the socket to the array */
      *(apr_socket_t **)apr_array_push(udp_send_array) = socket;
    }
}

/* This function will send a datagram to every udp_send_channel specified */
static int
udp_send_message( char *buf, int len )
{
  apr_status_t status;
  int i;
  int num_errors = 0;
  apr_size_t size;

  if(!buf)
    return 1;

  for(i=0; i< udp_send_array->nelts; i++)
    {
      apr_socket_t *socket = ((apr_socket_t **)(udp_send_array->elts))[i];
      size   = len;
      status = apr_socket_send( socket, buf, &size );
      if(status != APR_SUCCESS)
	{
	  num_errors++;
	}
    }
  return num_errors;
}

int
main ( int argc, char *argv[] )
{
  apr_interval_time_t start, end;
  apr_interval_time_t timeout = 0;

  /* Mark the time this gmond started */
  started = apr_time_now();

  if (cmdline_parser (argc, argv, &args_info) != 0)
    exit(1) ;

  if(args_info.default_config_flag)
    {
      fprintf(stderr, DEFAULT_CONFIGURATION);
      exit(0);
    }

  process_configuration_file();

  daemonize_if_necessary( argv );
  
  /* Initializes the apr library in ./srclib/apr */
  initialize_apr_library();

  /* Collect my hostname */
  apr_gethostname( myname, APRMAXHOSTLEN+1, global_context);

  /* Initialize the libmetrics library in ./srclib/libmetrics */
  libmetrics_init();

  /* Ignore any SIGPIPE signals */
  apr_signal( SIGPIPE, SIG_IGN );

  setuid_if_necessary();

  process_deaf_mute_mode();

  if(!deaf)
    {
      setup_udp_recv_pollset();
    }

  if(!mute)
    {
      setup_udp_send_array();
    }

  for(;;)
    {
      timeout = 2 * APR_USEC_PER_SEC;
      start = apr_time_now();
      if(!deaf)
	{
          poll_udp_recv_channels(timeout);  
	  /* accept_tcp_connections... */
	}

      if(!mute)
	{
	  /*
	  check_metric_values()... and if we need to...
	  udp_send_message( "This is a test", 15);
	  */
	}

      end = apr_time_now();
    }

  return 0;
}
